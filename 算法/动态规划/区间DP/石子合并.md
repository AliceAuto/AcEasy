
---

# 题目：最小合并代价

设有 $N$ 堆石子排成一排，其编号为 $1,2,3,\ldots,N$。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 $N$ 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 4 堆石子分别为 1 3 5 2，我们可以先合并 1、2 堆，代价为 4，得到 4 5 2，又合并 1、2 堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4+9+11=24；

如果第二步是先合并 2、3 堆，则代价为 7，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

## 输入格式

- 第一行一个数 $N$ 表示石子的堆数 $N$。
- 第二行 $N$ 个数，表示每堆石子的质量(均不超过 1000)。

## 输出格式

- 输出一个整数，表示最小代价。

## 数据范围

- $1 \leq N \leq 300$

## 输入样例：

```
4
1 3 5 2
```

## 输出样例：

```
22
```
---
## 题意

合并 $N$ 堆石子，每次只能合并相邻的两堆石子，求最小代价。

## 解题思路

### 关键点

最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并。

### 状态表示

$f[i][j]$ 表示将 $i$ 到 $j$ 这一段石子合并成一堆的方案的集合，属性 `Min`。

### 状态计算

1. 当 $i < j$ 时，状态转移方程为：
   $$
   f[i][j] = \min_{i \leq k \leq j-1} \{f[i][k] + f[k+1][j] + s[j] - s[i-1]\}
   $$
   其中，$s[i]$ 表示前缀和，即 $s[i] = \sum_{k=1}^{i} w[k]$。

2. 当 $i = j$ 时，$f[i][i] = 0$，因为合并一堆石子的代价为 0。

### 问题答案

$f[1][n]$ 即为将 1 到 $n$ 这一段石子全部合并成一堆的最小代价。

### 区间 DP 常用模板

所有的区间DP问题枚举时，第一维通常是枚举区间长度，并且一般 `len = 1` 时用来初始化，枚举从 `len = 2` 开始；第二维枚举起点 `i` （右端点 `j` 自动获得，`j = i + len - 1`）。

模板代码如下：

```cpp
for (int len = 1; len <= n; len++) {         // 区间长度
    for (int i = 1; i + len - 1 <= n; i++) { // 枚举起点
        int j = i + len - 1;                 // 区间终点
        if (len == 1) {
            dp[i][j] = 初始值;
            continue;
        }

        for (int k = i; k < j; k++) {        // 枚举分割点，构造状态转移方程
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + w[i][j]);
        }
    }
}
```

---



```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 310;

int f[N][N],a[N],n;

int main() {
    cin>>n;
    for(int i = 1; i <= n; i ++ ) cin>>a[i];
    for(int i = 1; i <= n; i ++ ) a[i] += a[i - 1];
    
    memset(f,0x3f,sizeof f);
    //模板
    for(int len = 1;len <= n; len ++ ) // len代表区间长度(点的个数)
        for(int i = 1; len + i - 1 <= n; i ++ ) { // i表示起点 限制条件为右端点要小于等于n
            int j = len + i - 1;
            if(len == 1) { // 当len为1时初始化  枚举从len = 2 时开始
                f[i][j] = 0; // 此时代价为0
                continue;
            }
            for(int k = i; k < j; k ++ ) { // 枚举分割点
                f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + a[j] - a[i-1]);
            }
        }
    cout<<f[1][n]<<endl;
    return 0;
}
```