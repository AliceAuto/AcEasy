---
layout: post
title: "K倍区间"
permalink: /刷题模块/OJ/蓝桥杯/每日一题/div3_{前缀和}_其他_K倍区间.md/
date: 2025-01-27
author: "JNMC李衍坤"
---

#### [备用返回通道](../../README.md)
#### 题目描述

给定一个长度为 $ N $ 的数列 $ A_1, A_2, \ldots, A_N $，如果其中一段连续的子序列 $ A_i, A_{i+1}, \ldots, A_j $ 之和是 $ K $ 的倍数，我们就称这个区间 $[i, j]$ 是 $ K $ 倍区间。

你能求出数列中总共有多少个 $ K $ 倍区间吗？

**输入格式**
- 第一行包含两个整数 $ N $ 和 $ K $。
- 以下 $ N $ 行每行包含一个整数 $ A_i $。

**输出格式**
- 输出一个整数，代表 $ K $ 倍区间的数目。

**数据范围**
- $ 1 \leq N, K \leq 100000 $
- $ 1 \leq A_i \leq 100000 $

**输入样例**：

**输入样例**：

```
5 2
1
2
3
4
5
```

**输出样例**：

```
6
```

#### 思路引导
根据题意：

- 我们需要找到元素sum为K的倍数的子区间的个数.
- 我们正面暴力的话，很容易想到一个$O(n^2)$的枚举方案,但是显然不能通过
- 我们要求的是"数量",而我们正面的"暴力枚举"实际上看起来是多搜索了左右边界的具体信息
- 我们希望不利用左右边界的信息
- 我们逆向思考一下，我们想要求这种性质子区间的数量。那么这种子区间的性质能不能再转化一下
- 我们可以发现:
   - 一个子区间sum为k，那他们的左右前缀和一定是差距着n*k的，
   那么 left_sum % k == right_sum % k
   - 反过来，我们也可以推导出:
   如果left_sum % k == right_sum % k,
   那么他们的区间和一定是n*k
   - 这是一个等价性质.
- 我们这样就把问题转化成了计数问题。没有必要左右边界的位置信息了
 
#### 代码

```C++
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5+10;

int sum[N],a[N],n,k;

long long res;

int main()
{
    cin>>n>>k;
    for(int i = 1; i <= n; i++)
    {
        cin>>a[i];
        a[i] += a[i - 1];
        a[i] %= k;
    }
    // 特判
    sum[0] = 1;
    
    for(int i = 1; i <= n; i ++)
    {
        res += sum[a[i]]++;   
        /*
            像哈希一样
            如果有相同的数 那么就会有一个区间
            依次枚举
        */
    }
    cout<<res<<endl;
    return 0;
}
```